'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getWindow = require('get-window');

var _getWindow2 = _interopRequireDefault(_getWindow);

var _selectionIsBackward = require('selection-is-backward');

var _selectionIsBackward2 = _interopRequireDefault(_selectionIsBackward);

var _environment = require('../constants/environment');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * CSS overflow values that would cause scrolling.
 *
 * @type {Array}
 */

var OVERFLOWS = ['auto', 'overlay', 'scroll'];

/**
 * Detect whether we are running IOS version 11
 */

var IS_IOS_11 = _environment.IS_IOS && !!window.navigator.userAgent.match(/os 11_/i);

/**
 * Find the nearest parent with scrolling, or window.
 *
 * @param {el} Element
 */

function findScrollContainer(el, window) {
  var parent = el.parentNode;
  var scroller = void 0;

  while (!scroller) {
    if (!parent.parentNode) break;

    var style = window.getComputedStyle(parent);
    var overflowY = style.overflowY;


    if (OVERFLOWS.includes(overflowY)) {
      scroller = parent;
      break;
    }

    parent = parent.parentNode;
  }

  // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're
  // assuming that window.scrollTo() should be used if the scrollable element
  // turns out to be document.body or document.documentElement. This will work
  // unless body is intentionally set to scrollable by restricting its height
  // (e.g. height: 100vh).
  if (!scroller) {
    return window.document.body;
  }

  return scroller;
}

/**
 * Scroll the current selection's focus point into view if needed.
 *
 * @param {Selection} selection
 */

function scrollToSelection(selection) {
  if (IS_IOS_11) return;
  if (!selection.anchorNode) return;

  var window = (0, _getWindow2.default)(selection.anchorNode);
  var scroller = findScrollContainer(selection.anchorNode, window);
  var isWindow = scroller == window.document.body || scroller == window.document.documentElement;
  var backward = (0, _selectionIsBackward2.default)(selection);

  var range = selection.getRangeAt(0).cloneRange();
  range.collapse(backward);
  var cursorRect = range.getBoundingClientRect();

  // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is
  // collapsed. Expanding the range by 1 is a relatively effective workaround
  // for vertical scroll, although horizontal may be off by 1 character.
  // https://bugs.webkit.org/show_bug.cgi?id=138949
  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438
  if (_environment.IS_SAFARI) {
    if (range.collapsed && cursorRect.top == 0 && cursorRect.height == 0) {
      if (range.startOffset == 0) {
        range.setEnd(range.endContainer, 1);
      } else {
        range.setStart(range.startContainer, range.startOffset - 1);
      }

      cursorRect = range.getBoundingClientRect();

      if (cursorRect.top == 0 && cursorRect.height == 0) {
        if (range.getClientRects().length) {
          cursorRect = range.getClientRects()[0];
        }
      }
    }
  }

  var width = void 0;
  var height = void 0;
  var yOffset = void 0;
  var xOffset = void 0;
  var scrollerTop = 0;
  var scrollerLeft = 0;
  var scrollerBordersY = 0;
  var scrollerBordersX = 0;
  var scrollerPaddingTop = 0;
  var scrollerPaddingBottom = 0;
  var scrollerPaddingLeft = 0;
  var scrollerPaddingRight = 0;

  if (isWindow) {
    var innerWidth = window.innerWidth,
        innerHeight = window.innerHeight,
        pageYOffset = window.pageYOffset,
        pageXOffset = window.pageXOffset;

    width = innerWidth;
    height = innerHeight;
    yOffset = pageYOffset;
    xOffset = pageXOffset;
  } else {
    var offsetWidth = scroller.offsetWidth,
        offsetHeight = scroller.offsetHeight,
        scrollTop = scroller.scrollTop,
        scrollLeft = scroller.scrollLeft;

    var _window$getComputedSt = window.getComputedStyle(scroller),
        borderTopWidth = _window$getComputedSt.borderTopWidth,
        borderBottomWidth = _window$getComputedSt.borderBottomWidth,
        borderLeftWidth = _window$getComputedSt.borderLeftWidth,
        borderRightWidth = _window$getComputedSt.borderRightWidth,
        paddingTop = _window$getComputedSt.paddingTop,
        paddingBottom = _window$getComputedSt.paddingBottom,
        paddingLeft = _window$getComputedSt.paddingLeft,
        paddingRight = _window$getComputedSt.paddingRight;

    var scrollerRect = scroller.getBoundingClientRect();
    width = offsetWidth;
    height = offsetHeight;
    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10);
    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10);
    scrollerBordersY = parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10);
    scrollerBordersX = parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10);
    scrollerPaddingTop = parseInt(paddingTop, 10);
    scrollerPaddingBottom = parseInt(paddingBottom, 10);
    scrollerPaddingLeft = parseInt(paddingLeft, 10);
    scrollerPaddingRight = parseInt(paddingRight, 10);
    yOffset = scrollTop;
    xOffset = scrollLeft;
  }

  var cursorTop = cursorRect.top + yOffset - scrollerTop;
  var cursorLeft = cursorRect.left + xOffset - scrollerLeft;

  var x = xOffset;
  var y = yOffset;

  if (cursorLeft < xOffset) {
    // selection to the left of viewport
    x = cursorLeft - scrollerPaddingLeft;
  } else if (cursorLeft + cursorRect.width + scrollerBordersX > xOffset + width) {
    // selection to the right of viewport
    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width;
  }

  if (cursorTop < yOffset) {
    // selection above viewport
    y = cursorTop - scrollerPaddingTop;
  } else if (cursorTop + cursorRect.height + scrollerBordersY > yOffset + height) {
    // selection below viewport
    y = cursorTop + scrollerBordersY + scrollerPaddingBottom + cursorRect.height - height;
  }

  if (isWindow) {
    window.scrollTo(x, y);
  } else {
    scroller.scrollTop = y;
    scroller.scrollLeft = x;
  }
}

/**
 * Export.
 *
 * @type {Function}
 */

exports.default = scrollToSelection;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9zY3JvbGwtdG8tc2VsZWN0aW9uLmpzIl0sIm5hbWVzIjpbIk9WRVJGTE9XUyIsIklTX0lPU18xMSIsIndpbmRvdyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm1hdGNoIiwiZmluZFNjcm9sbENvbnRhaW5lciIsImVsIiwicGFyZW50IiwicGFyZW50Tm9kZSIsInNjcm9sbGVyIiwic3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3dZIiwiaW5jbHVkZXMiLCJkb2N1bWVudCIsImJvZHkiLCJzY3JvbGxUb1NlbGVjdGlvbiIsInNlbGVjdGlvbiIsImFuY2hvck5vZGUiLCJpc1dpbmRvdyIsImRvY3VtZW50RWxlbWVudCIsImJhY2t3YXJkIiwicmFuZ2UiLCJnZXRSYW5nZUF0IiwiY2xvbmVSYW5nZSIsImNvbGxhcHNlIiwiY3Vyc29yUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNvbGxhcHNlZCIsInRvcCIsImhlaWdodCIsInN0YXJ0T2Zmc2V0Iiwic2V0RW5kIiwiZW5kQ29udGFpbmVyIiwic2V0U3RhcnQiLCJzdGFydENvbnRhaW5lciIsImdldENsaWVudFJlY3RzIiwibGVuZ3RoIiwid2lkdGgiLCJ5T2Zmc2V0IiwieE9mZnNldCIsInNjcm9sbGVyVG9wIiwic2Nyb2xsZXJMZWZ0Iiwic2Nyb2xsZXJCb3JkZXJzWSIsInNjcm9sbGVyQm9yZGVyc1giLCJzY3JvbGxlclBhZGRpbmdUb3AiLCJzY3JvbGxlclBhZGRpbmdCb3R0b20iLCJzY3JvbGxlclBhZGRpbmdMZWZ0Iiwic2Nyb2xsZXJQYWRkaW5nUmlnaHQiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJwYWdlWU9mZnNldCIsInBhZ2VYT2Zmc2V0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0Iiwic2Nyb2xsZXJSZWN0IiwicGFyc2VJbnQiLCJsZWZ0IiwiY3Vyc29yVG9wIiwiY3Vyc29yTGVmdCIsIngiLCJ5Iiwic2Nyb2xsVG8iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7QUFNQSxJQUFNQSxZQUFZLENBQ2hCLE1BRGdCLEVBRWhCLFNBRmdCLEVBR2hCLFFBSGdCLENBQWxCOztBQU1BOzs7O0FBSUEsSUFBTUMsWUFBWSx1QkFBVSxDQUFDLENBQUNDLE9BQU9DLFNBQVAsQ0FBaUJDLFNBQWpCLENBQTJCQyxLQUEzQixDQUFpQyxTQUFqQyxDQUE5Qjs7QUFFQTs7Ozs7O0FBTUEsU0FBU0MsbUJBQVQsQ0FBNkJDLEVBQTdCLEVBQWlDTCxNQUFqQyxFQUF5QztBQUN2QyxNQUFJTSxTQUFTRCxHQUFHRSxVQUFoQjtBQUNBLE1BQUlDLGlCQUFKOztBQUVBLFNBQU8sQ0FBQ0EsUUFBUixFQUFrQjtBQUNoQixRQUFJLENBQUNGLE9BQU9DLFVBQVosRUFBd0I7O0FBRXhCLFFBQU1FLFFBQVFULE9BQU9VLGdCQUFQLENBQXdCSixNQUF4QixDQUFkO0FBSGdCLFFBSVJLLFNBSlEsR0FJTUYsS0FKTixDQUlSRSxTQUpROzs7QUFNaEIsUUFBSWIsVUFBVWMsUUFBVixDQUFtQkQsU0FBbkIsQ0FBSixFQUFtQztBQUNqQ0gsaUJBQVdGLE1BQVg7QUFDQTtBQUNEOztBQUVEQSxhQUFTQSxPQUFPQyxVQUFoQjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJLENBQUNDLFFBQUwsRUFBZTtBQUNiLFdBQU9SLE9BQU9hLFFBQVAsQ0FBZ0JDLElBQXZCO0FBQ0Q7O0FBRUQsU0FBT04sUUFBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQSxTQUFTTyxpQkFBVCxDQUEyQkMsU0FBM0IsRUFBc0M7QUFDcEMsTUFB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QUFJc0IsYUFBYTNDLFdBQVdZLEtBQXhCLEdBQWdDTSxnQkFBaEMsR0FBbURKLFVBQVVGLEtBQWpFLEVBQXdFO0FBQzdFO0FBQ0FnQyxRQUFJRCxhQUFhekIsZ0JBQWIsR0FBZ0NJLG9CQUFoQyxHQUF1RFYsS0FBM0Q7QUFDRDs7QUFFRCxNQUFJOEIsWUFBWTdCLE9BQWhCLEVBQXlCO0FBQ3ZCO0FBQ0FnQyxRQUFJSCxZQUFZdkIsa0JBQWhCO0FBQ0QsR0FIRCxNQUdPLElBQUl1QixZQUFZMUMsV0FBV0ksTUFBdkIsR0FBZ0NhLGdCQUFoQyxHQUFtREosVUFBVVQsTUFBakUsRUFBeUU7QUFDOUU7QUFDQXlDLFFBQUlILFlBQVl6QixnQkFBWixHQUErQkcscUJBQS9CLEdBQXVEcEIsV0FBV0ksTUFBbEUsR0FBMkVBLE1BQS9FO0FBQ0Q7O0FBR0QsTUFBSVgsUUFBSixFQUFjO0FBQ1psQixXQUFPdUUsUUFBUCxDQUFnQkYsQ0FBaEIsRUFBbUJDLENBQW5CO0FBQ0QsR0FGRCxNQUVPO0FBQ0w5RCxhQUFTOEMsU0FBVCxHQUFxQmdCLENBQXJCO0FBQ0E5RCxhQUFTK0MsVUFBVCxHQUFzQmMsQ0FBdEI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7a0JBTWV0RCxpQiIsImZpbGUiOiJzY3JvbGwtdG8tc2VsZWN0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJ2dldC13aW5kb3cnXG5pbXBvcnQgaXNCYWNrd2FyZCBmcm9tICdzZWxlY3Rpb24taXMtYmFja3dhcmQnXG5pbXBvcnQgeyBJU19TQUZBUkksIElTX0lPUyB9IGZyb20gJy4uL2NvbnN0YW50cy9lbnZpcm9ubWVudCdcblxuLyoqXG4gKiBDU1Mgb3ZlcmZsb3cgdmFsdWVzIHRoYXQgd291bGQgY2F1c2Ugc2Nyb2xsaW5nLlxuICpcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG5jb25zdCBPVkVSRkxPV1MgPSBbXG4gICdhdXRvJyxcbiAgJ292ZXJsYXknLFxuICAnc2Nyb2xsJyxcbl1cblxuLyoqXG4gKiBEZXRlY3Qgd2hldGhlciB3ZSBhcmUgcnVubmluZyBJT1MgdmVyc2lvbiAxMVxuICovXG5cbmNvbnN0IElTX0lPU18xMSA9IElTX0lPUyAmJiAhIXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9vcyAxMV8vaSlcblxuLyoqXG4gKiBGaW5kIHRoZSBuZWFyZXN0IHBhcmVudCB3aXRoIHNjcm9sbGluZywgb3Igd2luZG93LlxuICpcbiAqIEBwYXJhbSB7ZWx9IEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBmaW5kU2Nyb2xsQ29udGFpbmVyKGVsLCB3aW5kb3cpIHtcbiAgbGV0IHBhcmVudCA9IGVsLnBhcmVudE5vZGVcbiAgbGV0IHNjcm9sbGVyXG5cbiAgd2hpbGUgKCFzY3JvbGxlcikge1xuICAgIGlmICghcGFyZW50LnBhcmVudE5vZGUpIGJyZWFrXG5cbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudClcbiAgICBjb25zdCB7IG92ZXJmbG93WSB9ID0gc3R5bGVcblxuICAgIGlmIChPVkVSRkxPV1MuaW5jbHVkZXMob3ZlcmZsb3dZKSkge1xuICAgICAgc2Nyb2xsZXIgPSBwYXJlbnRcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGVcbiAgfVxuXG4gIC8vIENPTVBBVDogQmVjYXVzZSBDaHJvbWUgZG9lcyBub3QgYWxsb3cgZG91Y21lbnQuYm9keS5zY3JvbGxUb3AsIHdlJ3JlXG4gIC8vIGFzc3VtaW5nIHRoYXQgd2luZG93LnNjcm9sbFRvKCkgc2hvdWxkIGJlIHVzZWQgaWYgdGhlIHNjcm9sbGFibGUgZWxlbWVudFxuICAvLyB0dXJucyBvdXQgdG8gYmUgZG9jdW1lbnQuYm9keSBvciBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuIFRoaXMgd2lsbCB3b3JrXG4gIC8vIHVubGVzcyBib2R5IGlzIGludGVudGlvbmFsbHkgc2V0IHRvIHNjcm9sbGFibGUgYnkgcmVzdHJpY3RpbmcgaXRzIGhlaWdodFxuICAvLyAoZS5nLiBoZWlnaHQ6IDEwMHZoKS5cbiAgaWYgKCFzY3JvbGxlcikge1xuICAgIHJldHVybiB3aW5kb3cuZG9jdW1lbnQuYm9keVxuICB9XG5cbiAgcmV0dXJuIHNjcm9sbGVyXG59XG5cbi8qKlxuICogU2Nyb2xsIHRoZSBjdXJyZW50IHNlbGVjdGlvbidzIGZvY3VzIHBvaW50IGludG8gdmlldyBpZiBuZWVkZWQuXG4gKlxuICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbGVjdGlvblxuICovXG5cbmZ1bmN0aW9uIHNjcm9sbFRvU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICBpZiAoSVNfSU9TXzExKSByZXR1cm5cbiAgaWYgKCFzZWxlY3Rpb24uYW5jaG9yTm9kZSkgcmV0dXJuXG5cbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KHNlbGVjdGlvbi5hbmNob3JOb2RlKVxuICBjb25zdCBzY3JvbGxlciA9IGZpbmRTY3JvbGxDb250YWluZXIoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHdpbmRvdylcbiAgY29uc3QgaXNXaW5kb3cgPSBzY3JvbGxlciA9PSB3aW5kb3cuZG9jdW1lbnQuYm9keSB8fCBzY3JvbGxlciA9PSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gIGNvbnN0IGJhY2t3YXJkID0gaXNCYWNrd2FyZChzZWxlY3Rpb24pXG5cbiAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5jbG9uZVJhbmdlKClcbiAgcmFuZ2UuY29sbGFwc2UoYmFja3dhcmQpXG4gIGxldCBjdXJzb3JSZWN0ID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAvLyBDT01QQVQ6IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHJldHVybnMgMHMgaW4gU2FmYXJpIHdoZW4gcmFuZ2UgaXNcbiAgLy8gY29sbGFwc2VkLiBFeHBhbmRpbmcgdGhlIHJhbmdlIGJ5IDEgaXMgYSByZWxhdGl2ZWx5IGVmZmVjdGl2ZSB3b3JrYXJvdW5kXG4gIC8vIGZvciB2ZXJ0aWNhbCBzY3JvbGwsIGFsdGhvdWdoIGhvcml6b250YWwgbWF5IGJlIG9mZiBieSAxIGNoYXJhY3Rlci5cbiAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzODk0OVxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00MzU0MzhcbiAgaWYgKElTX1NBRkFSSSkge1xuICAgIGlmIChyYW5nZS5jb2xsYXBzZWQgJiYgY3Vyc29yUmVjdC50b3AgPT0gMCAmJiBjdXJzb3JSZWN0LmhlaWdodCA9PSAwKSB7XG4gICAgICBpZiAocmFuZ2Uuc3RhcnRPZmZzZXQgPT0gMCkge1xuICAgICAgICByYW5nZS5zZXRFbmQocmFuZ2UuZW5kQ29udGFpbmVyLCAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0IC0gMSlcbiAgICAgIH1cblxuICAgICAgY3Vyc29yUmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgIGlmIChjdXJzb3JSZWN0LnRvcCA9PSAwICYmIGN1cnNvclJlY3QuaGVpZ2h0ID09IDApIHtcbiAgICAgICAgaWYgKHJhbmdlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgY3Vyc29yUmVjdCA9IHJhbmdlLmdldENsaWVudFJlY3RzKClbMF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCB3aWR0aFxuICBsZXQgaGVpZ2h0XG4gIGxldCB5T2Zmc2V0XG4gIGxldCB4T2Zmc2V0XG4gIGxldCBzY3JvbGxlclRvcCA9IDBcbiAgbGV0IHNjcm9sbGVyTGVmdCA9IDBcbiAgbGV0IHNjcm9sbGVyQm9yZGVyc1kgPSAwXG4gIGxldCBzY3JvbGxlckJvcmRlcnNYID0gMFxuICBsZXQgc2Nyb2xsZXJQYWRkaW5nVG9wID0gMFxuICBsZXQgc2Nyb2xsZXJQYWRkaW5nQm90dG9tID0gMFxuICBsZXQgc2Nyb2xsZXJQYWRkaW5nTGVmdCA9IDBcbiAgbGV0IHNjcm9sbGVyUGFkZGluZ1JpZ2h0ID0gMFxuXG4gIGlmIChpc1dpbmRvdykge1xuICAgIGNvbnN0IHsgaW5uZXJXaWR0aCwgaW5uZXJIZWlnaHQsIHBhZ2VZT2Zmc2V0LCBwYWdlWE9mZnNldCB9ID0gd2luZG93XG4gICAgd2lkdGggPSBpbm5lcldpZHRoXG4gICAgaGVpZ2h0ID0gaW5uZXJIZWlnaHRcbiAgICB5T2Zmc2V0ID0gcGFnZVlPZmZzZXRcbiAgICB4T2Zmc2V0ID0gcGFnZVhPZmZzZXRcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQsIHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCB9ID0gc2Nyb2xsZXJcbiAgICBjb25zdCB7XG4gICAgICBib3JkZXJUb3BXaWR0aCxcbiAgICAgIGJvcmRlckJvdHRvbVdpZHRoLFxuICAgICAgYm9yZGVyTGVmdFdpZHRoLFxuICAgICAgYm9yZGVyUmlnaHRXaWR0aCxcbiAgICAgIHBhZGRpbmdUb3AsXG4gICAgICBwYWRkaW5nQm90dG9tLFxuICAgICAgcGFkZGluZ0xlZnQsXG4gICAgICBwYWRkaW5nUmlnaHQsXG4gICAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGVyKVxuXG4gICAgY29uc3Qgc2Nyb2xsZXJSZWN0ID0gc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICB3aWR0aCA9IG9mZnNldFdpZHRoXG4gICAgaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0XG4gICAgc2Nyb2xsZXJUb3AgPSBzY3JvbGxlclJlY3QudG9wICsgcGFyc2VJbnQoYm9yZGVyVG9wV2lkdGgsIDEwKVxuICAgIHNjcm9sbGVyTGVmdCA9IHNjcm9sbGVyUmVjdC5sZWZ0ICsgcGFyc2VJbnQoYm9yZGVyTGVmdFdpZHRoLCAxMClcbiAgICBzY3JvbGxlckJvcmRlcnNZID0gcGFyc2VJbnQoYm9yZGVyVG9wV2lkdGgsIDEwKSArIHBhcnNlSW50KGJvcmRlckJvdHRvbVdpZHRoLCAxMClcbiAgICBzY3JvbGxlckJvcmRlcnNYID0gcGFyc2VJbnQoYm9yZGVyTGVmdFdpZHRoLCAxMCkgKyBwYXJzZUludChib3JkZXJSaWdodFdpZHRoLCAxMClcbiAgICBzY3JvbGxlclBhZGRpbmdUb3AgPSBwYXJzZUludChwYWRkaW5nVG9wLCAxMClcbiAgICBzY3JvbGxlclBhZGRpbmdCb3R0b20gPSBwYXJzZUludChwYWRkaW5nQm90dG9tLCAxMClcbiAgICBzY3JvbGxlclBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQocGFkZGluZ0xlZnQsIDEwKVxuICAgIHNjcm9sbGVyUGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQocGFkZGluZ1JpZ2h0LCAxMClcbiAgICB5T2Zmc2V0ID0gc2Nyb2xsVG9wXG4gICAgeE9mZnNldCA9IHNjcm9sbExlZnRcbiAgfVxuXG4gIGNvbnN0IGN1cnNvclRvcCA9IGN1cnNvclJlY3QudG9wICsgeU9mZnNldCAtIHNjcm9sbGVyVG9wXG4gIGNvbnN0IGN1cnNvckxlZnQgPSBjdXJzb3JSZWN0LmxlZnQgKyB4T2Zmc2V0IC0gc2Nyb2xsZXJMZWZ0XG5cbiAgbGV0IHggPSB4T2Zmc2V0XG4gIGxldCB5ID0geU9mZnNldFxuXG4gIGlmIChjdXJzb3JMZWZ0IDwgeE9mZnNldCkge1xuICAgIC8vIHNlbGVjdGlvbiB0byB0aGUgbGVmdCBvZiB2aWV3cG9ydFxuICAgIHggPSBjdXJzb3JMZWZ0IC0gc2Nyb2xsZXJQYWRkaW5nTGVmdFxuICB9IGVsc2UgaWYgKGN1cnNvckxlZnQgKyBjdXJzb3JSZWN0LndpZHRoICsgc2Nyb2xsZXJCb3JkZXJzWCA+IHhPZmZzZXQgKyB3aWR0aCkge1xuICAgIC8vIHNlbGVjdGlvbiB0byB0aGUgcmlnaHQgb2Ygdmlld3BvcnRcbiAgICB4ID0gY3Vyc29yTGVmdCArIHNjcm9sbGVyQm9yZGVyc1ggKyBzY3JvbGxlclBhZGRpbmdSaWdodCAtIHdpZHRoXG4gIH1cblxuICBpZiAoY3Vyc29yVG9wIDwgeU9mZnNldCkge1xuICAgIC8vIHNlbGVjdGlvbiBhYm92ZSB2aWV3cG9ydFxuICAgIHkgPSBjdXJzb3JUb3AgLSBzY3JvbGxlclBhZGRpbmdUb3BcbiAgfSBlbHNlIGlmIChjdXJzb3JUb3AgKyBjdXJzb3JSZWN0LmhlaWdodCArIHNjcm9sbGVyQm9yZGVyc1kgPiB5T2Zmc2V0ICsgaGVpZ2h0KSB7XG4gICAgLy8gc2VsZWN0aW9uIGJlbG93IHZpZXdwb3J0XG4gICAgeSA9IGN1cnNvclRvcCArIHNjcm9sbGVyQm9yZGVyc1kgKyBzY3JvbGxlclBhZGRpbmdCb3R0b20gKyBjdXJzb3JSZWN0LmhlaWdodCAtIGhlaWdodFxuICB9XG5cblxuICBpZiAoaXNXaW5kb3cpIHtcbiAgICB3aW5kb3cuc2Nyb2xsVG8oeCwgeSlcbiAgfSBlbHNlIHtcbiAgICBzY3JvbGxlci5zY3JvbGxUb3AgPSB5XG4gICAgc2Nyb2xsZXIuc2Nyb2xsTGVmdCA9IHhcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9ydC5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgc2Nyb2xsVG9TZWxlY3Rpb25cbiJdfQ==